---
title: "Blocker Project: Differential Expression using DESeq2- Command line miRDeep2 count matrix used"
output: html_notebook
---

#Using DESeq2 to perform differential expression on miRNASeq data, comparing blocked vs no blocked groups

****Note: this notebook uses only the count matrix generated by the command line miRDeep2 analysis, with default settings. This entire analysis was also run on the count matrix generated by BaseSpace miRDeep2. See "FINAL_DifferentialExpression_BaseSpaceCountMatrix_BlockerProject.Rmd" for this analysis.

Import libraries:
```{r}
suppressPackageStartupMessages(library(DESeq2))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(metaseqR))
suppressPackageStartupMessages(library(colorRamps))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(ggrepel))
windowsFonts("Arial" = windowsFont("Arial"))
```


#Functions used in analyses:
```{r}
#Create metadata and DESeq2 object, then run DESeq2

RunDESeq2<- function(counts,meta, collapseRep=TRUE) {
  #create DESeq2 object- just based on samplegroup (blockerstatus)
  #will add samples to model later (i.e., pairwise analysis)
  dds<- DESeqDataSetFromMatrix(countData=counts, 
                               colData=meta, 
                               design=~sampleGroup)
  #Collapse technical replicates using internal DESeq2 function
  if (collapseRep ==TRUE){
    dds<- collapseReplicates(dds, dds$sample)
  }
  
  #Create model that takes into account sample differences
  ddsMF<- dds
  design(ddsMF)<- formula(~Patient + sampleGroup)
  
  #run DESeq2
  dds<- DESeq(ddsMF)
  
  return(dds)
}

#Get DE results
GetDEResults<- function(dds){
  res<- results(dds)
  res<- na.omit(res)
  resOrdered<- res[order(res$padj),]
  print(nrow(resOrdered[resOrdered$padj<0.05,]))
  print(nrow(resOrdered[resOrdered$padj<0.01,]))
  return(resOrdered)
}
MyPCA<- function(dds, metadata, PC1Variance, PC2Variance, Groupcolors,miny, maxy, minx, maxx) {
  #Normalized (variance stabilized transformation), then run PCA
  vsd <- varianceStabilizingTransformation(dds, blind=TRUE)
  PCA<-plotPCA(vsd, intgroup="sampleGroup",returnData=TRUE)
  PCA$Patient<- metadata$Patient
  
  #plot
  p<- ggplot(PCA, aes(x=PC1, y=PC2, color=group, shape=Patient))+
  geom_point(size=8)+
  scale_color_manual(values=Groupcolors)+
  scale_shape_manual(values=c(15,20,43,18))+
  theme_classic()+
  ylim(miny,maxy)+
  xlim(minx,maxx)+
  ylab(paste("PC2: ", PC2Variance, "% Variance", sep =""))+
  xlab(paste("PC1: ", PC1Variance, "% Variance", sep =""))+
  #geom_text(aes(label=Sample),hjust=.5, size= 5,vjust=-1.2, color="black")+
  theme(axis.text.y   = element_text(size=12, colour = "black", face="bold"),
        axis.title.y  = element_text(size=14, colour = "black", face="bold"),
        axis.title.x  = element_text(size=14, colour = "black", face="bold"),
        axis.text.x  = element_text(size=12, colour = "black", face="bold"),
        legend.background = element_rect(fill=NA, size=1, 
                                         linetype="solid", color="black"),
        legend.title=element_blank(),
        legend.text = element_text(size=14, face="bold"),
        legend.key.size = unit(.4, "cm"),
        legend.spacing.y = unit(0, "mm"),
        legend.position = c(.9,.85),
        panel.border = element_rect(colour = "black", fill=NA, size=2))
  return(p)
}

MyPCA_TechNotCollapsed<- function(counts, meta,PC1, PC2, miny, maxy, minx, maxx){
  #Rename samples
  TechNotCollapsed<- counts
  colnames(TechNotCollapsed)<- c(paste("A.0.", 1:3,sep=""), paste("B.0.", 1:3,sep=""), "C.0", "D.0", paste("A.1.", 1:3,sep=""), paste("B.1.", 1:3,sep=""), "C.1", "D.1")


  #create DESeq2 object
  dds_TNC<- DESeqDataSetFromMatrix(countData=TechNotCollapsed, 
                             colData=meta, 
                             design=~sampleGroup)


  #Create model that takes into account sample differences
  ddsMF_TNC<- dds_TNC
  design(ddsMF_TNC)<- formula(~Patient + sampleGroup)

  #run DESeq2
  dds_TNC<- DESeq(ddsMF_TNC)
  
  #Run through MyPCA function to plot
  p<- MyPCA(dds_TNC, meta, PC1, PC2, Groupcolors, miny, maxy, minx, maxx)
  return(p)
}
  


#Plot heatmap: takes as input DE results (padj ordered lowest to highest, rlog transformed data, metadata (blocker status and Sample type), number of miRNA species to be included, and min and max subtract (used for heatmap aesthetics))

PlotHeatmap<- function(OrderedResults, rld, metadata, nspecies, MinSubtract, MaxSubtract, fontsize){
  #Select top sig DE miRNAs
  topgenes<- rownames(OrderedResults[1:nspecies,])
  mat<- assay(rld)[topgenes,]
  mat<- mat - rowMeans(mat)
  colnames(mat)<-paste(metadata$Patient," (",metadata$sampleGroup, ")",sep="")
  
  #Heatmap settings
  mat_breaks<- seq(min(mat-MinSubtract), max(mat-MaxSubtract), length.out=75)

  #Create metadata- to be used to color code to show which group the sample belongs to
  metadata<- data.frame(Group=metadata$sampleGroup, 
                        row.names=paste(metadata$Patient," (",metadata$sampleGroup, ")",sep=""),
                        Sample=metadata$Patient)

  #plot heatmap
  p<-pheatmap(mat, breaks = mat_breaks, 
            color =colorRampPalette( c("red", "black", "green"), space="rgb")(100),
            show_rownames = TRUE, show_colnames=FALSE,
            annotation = metadata,
            annotation_colors= list(
              Group=c(Blocked="firebrick3", Unblocked="turquoise3"),
                      Sample=c(A="goldenrod1", 
                               B="violetred3", 
                               C="skyblue3", 
                               D="darkolivegreen4")),
            fontsize_row = fontsize,fontsize=12,treeheight_row=0,
            border_color= NA)
  return(p)
}


#Plot log of cpm of raw counts- coloring based on whether it's differentially expressed
CPMPlot<- function(CPM, Sample){
  #Get subset of CPM for labeling points- points that are both sig DE and are higher in unblocked than   blocked (beneath the slope line)
  CPM$HigherInUnblocked<- (CPM$Blocker-CPM$NoBlocker)<0
  SubsetToLabel<- CPM[CPM$HigherInUnblocked=="TRUE" &CPM$Color!="Not DE",]
  
  #Plot
  p<- ggplot(CPM, aes(x=NoBlocker, y=Blocker, color=Color))+
  geom_point(size=3)+
  geom_abline(slope=1, color="red")+
  scale_colour_manual(values=c("red","black", "blue"))+
  theme_classic()+
  xlim(0,6)+
  ylim(0,6)+
  xlab(paste("Log of Unblocked Counts Per Million: ", Sample, sep =""))+
  ylab(paste("Log of Blocked Counts Per Million: ", Sample, sep =""))+
  geom_text_repel(data=SubsetToLabel, aes(x=NoBlocker, y=Blocker, label=rownames(SubsetToLabel)), color="black",  size=5, fontface="bold")+
  theme(axis.text.y   = element_text(size=14, colour = "black", face="bold"),
        axis.title.y  = element_text(size=18, colour = "black", face="bold"),
        axis.title.x  = element_text(size=18, colour = "black", face="bold"),
        axis.text.x  = element_text(size=14, colour = "black", face="bold"),
        legend.background = element_rect(fill=NA, size=1, 
                                         linetype="solid", color="black"),
        legend.title=element_blank(),
        legend.key.size = unit(.4, "cm"),
        legend.spacing.y = unit(0, "mm"),
        legend.position = c(.15,.892),
        legend.text = element_text(size=18, face="bold"),
        panel.border = element_rect(colour = "black", fill=NA, size=2))
  return(p)
  
}

```



#Notes on DESeq2 Analysis:

-Since there are 4 sample types (A/B/C/D) each with at least one blocked/unblocked pair, pairwise DESeq2 analysis is performed

-Samples A and B have 3 technical replicates, for both blocked and unblocked groups. These technical replicates are collapsed using an internal DESeq2 function. These technical replicates have varying RNA input amounts into library construction, but this was determined to have no effect on the resulting libraries (See ___.Rmd). This is additionally confirmed by PCA clustering here.


#Read in data and downsample

```{r}
#readwd<-"Z:/Channing_miRNA_Blocker_Test/BlockerProject/BlockerProject/RawData/"
#countsInput<- read.csv(paste(readwd, "miRNA_CLmiRDeep2Results_AllSamples_DefaultmiRDeep2Settings.csv", sep=""))
countsInput<- read.csv("C:/Users/Jenna/Documents/BlockerProject/miRNA_CLmiRDeep2Results_AllSamples_DefaultmiRDeep2Settings.csv")
rownames(countsInput)<-countsInput$X
countsInput<- countsInput[,-1]
countsInput<- countsInput[,c(1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16)]
colnames(countsInput)<- c(paste(c("A:low", "A:medium", "A:high", "B:low", "B:medium", "B:high", "C", "D"), "-Unblocked",sep=""),
                          paste( c("A:low", "A:medium", "A:high","B:low", "B:medium", "B:high", "C", "D"), "-Blocked",sep="" ))

#Downsample to common depth
counts<- downsample.counts(countsInput, set.seed(42)) #9,989,167 lowest B.570.0

#Convert values to integer
counts<-as.data.frame(apply(counts, 2, as.integer))
rownames(counts)<- rownames(countsInput)
```


```{r}
#Need to detach DESeq (need to use DESeq2)- used for metaseqR
detach("package:metaseqR")
detach("package:DESeq")
```

General plotting variables
```{r}
Groupcolors<- c("firebrick3","turquoise3")
Samplecolors<- c("goldenrod1","violetred3", "skyblue3", "darkolivegreen4")

metadata<- data.frame(sampleGroup=rep(c("Unblocked", "Blocked"),4), Patient=c("A", "A", "B", "B", "C", "C", "D", "D"))
```



#Figure 2A: PCA

Prep data for DESeq2, create metadata and DESeq2 object, then run DESeq2:
```{r}
#rename rows, removing input info
colnames(counts)<- c(rep("A.0", 3), rep("B.0", 3), "C.0", "D.0", rep("A.1", 3), rep("B.1", 3), "C.1", "D.1")

#Create metadata- will be used in all analyses- when collapsing technical replicates and when leaving separate:
sampleGroup<- as.factor(c(rep("Unblocked", 8), rep("Blocked", 8))) #set blocker status
sample<- colnames(counts) #this column is used to collapse technical replicates
Patient<- as.factor(c(rep("A", 3), rep("B", 3), "C", "D", rep("A", 3), rep("B", 3), "C", "D")) #this column is to control for sample to sample differences
meta<- data.frame(sample, sampleGroup, Patient)

#Run DESeq2- using custom function
#Technical replicates are collapsed and pairwise analysis performed

dds<- RunDESeq2(counts, meta, TRUE)
```

Visualize sample differences using PCA

Note: this function uses the dds object, but no information on sample group is input into the analysis (i.e., unsupervised clustering)


```{r}
#Plot PCA using DESeq2 functions, get % variance from here. Input for custom function.
plotPCA(varianceStabilizingTransformation(dds), intgroup="sampleGroup")

p<-MyPCA(dds, metadata, 43, 18, Groupcolors,-15,20, -20,25)
```



Repeat PCA, not collapsing technical replicates
```{r}
#Run deseq2 --> plot on PCA
p<- MyPCA_TechNotCollapsed(counts, meta, 43, 18, -20,27,-25,28) #This graph exported as 032320_Figure2A_PCA
```
#Figure 2B: "Rank Sum"

```{r}
#calculate cpm
cpm<- counts/colSums(counts) * 1000000

#Collapse into two groups: blocked and unblocked
TopSpecies<-cpm
TopSpecies$Unblocked<- rowMeans(TopSpecies[,1:8])
TopSpecies$Blocked<- rowMeans(TopSpecies[,9:16])

##Select just the top 20 Unblocked species
TopSpecies<- TopSpecies[order(TopSpecies$Unblocked, decreasing=TRUE),]
TopSpecies<- TopSpecies[1:20, 17:18]



#calculate Percentage of total reads- will be secondary y axis on plot
Unblocked_Top<- rowMeans(counts[rownames(counts) %in% rownames(TopSpecies), 1:8])
Unblocked_percentage<-as.data.frame(Unblocked_Top/mean(colSums(counts[,1:8]))*100)
Unblocked_percentage$species<- rownames(Unblocked_percentage)
colnames(Unblocked_percentage)<- c("Unblocked_Per", "species")
Unblocked_percentage[21,]<- c(100-sum(Unblocked_percentage[,1]), "AllOthers")

blocked_Top<- rowMeans(counts[rownames(counts) %in% rownames(TopSpecies), 9:16])
blocked_percentage<-as.data.frame(blocked_Top/mean(colSums(counts[,9:16]))*100)
blocked_percentage$species<- rownames(blocked_percentage)
colnames(blocked_percentage)<- c("blocked_Per", "species")
blocked_percentage[21,]<- c(100-sum(blocked_percentage[,1]), "AllOthers")

#Calculate CPM for all other species not in top 20 (from percentage)
TopSpecies[21,]<- c(as.numeric(Unblocked_percentage[21,1])*10000, 
                    as.numeric(blocked_percentage[21,1]) * 10000)
rownames(TopSpecies)<- c(rownames(TopSpecies[1:20,]), "AllOthers")
TopSpecies$species<- rownames(TopSpecies)

#Merge with CPM for 5 total colums: species/unblocked cpm/blocked cpm/ unblocked percentage/blocked percentage
merging<-merge(TopSpecies, Unblocked_percentage, by="species")
TopSpecies_Final<-merge(merging, blocked_percentage, by="species")
AllOthers<-TopSpecies_Final[grep("AllOthers", TopSpecies_Final$species),]
TopSpecies_Final<- TopSpecies_Final[-1,]
TopSpecies_Final<- TopSpecies_Final[order(TopSpecies_Final$Unblocked, decreasing=TRUE),]
TopSpecies_Final<- rbind(TopSpecies_Final, AllOthers)

#Reformat for plotting
TopSpecies_melt<- melt(TopSpecies_Final, id="species")
TopSpecies_Plot<- cbind(TopSpecies_melt[1:42,], TopSpecies_melt[43:84,])
TopSpecies_Plot<-TopSpecies_Plot[,c(1,2,3,6)]
colnames(TopSpecies_Plot)<- c("species", "BlockerStatus", "CPM", "Percentage")
TopSpecies_Plot$SpeciesOrder<- rep(1:21,2)
TopSpecies_Plot$StatusOrder<- c(rep(1,21), rep(2,21))
TopSpecies_Plot$CPM<- as.integer(TopSpecies_Plot$CPM)


p<- ggplot(TopSpecies_Plot, aes(x=reorder(species, + SpeciesOrder), 
                                y=CPM,
                                group=StatusOrder,
                                fill=factor(BlockerStatus, levels=c("Blocked", "Unblocked"))))+
        geom_bar( stat="identity",width= .8, position=position_dodge(width = 0.7))+
        theme_classic()+
        xlab("")+
        scale_y_continuous(name = "Counts Per Million",
                           sec.axis = sec_axis( trans=~.*.0001, 
                                                name="Percentage of Total Reads", 
                                                breaks=seq(0,50, by=10),
                                                labels=paste(seq(0,50,by=10), "%", sep="")),
                           limits=c(0,500000),
                           breaks= seq(0,500000, by=100000),
                           labels=c("0", "100,000", "200,000", "300,000", "400,000", "500,000"))+
        scale_fill_manual("", values=c("Blocked"="firebrick3", "Unblocked"="turquoise3"))+
        theme(axis.text.y   = element_text(size=14, colour = "black", face="bold"),
                axis.title.y  = element_text(size=18, colour = "black", face="bold"),
                axis.text.x  = element_text(size=14, colour = "black", face="bold", angle=45, hjust=1),
                legend.background = element_rect(fill=NA, size=1, 
                                         linetype="solid", color="black"),
                legend.title=element_blank(),
                legend.key.size = unit(.4, "cm"),
                legend.spacing.y = unit(0, "mm"),
                legend.position = c(.84,.88),
                legend.text = element_text(size=18, face="bold"),
                panel.border = element_rect(colour = "black", fill=NA, size=2))

```




#Figure 2C: Differential expression


#Back to using the dds object with technical replicates collapsed:


Differential expression results:
```{r}
resOrdered<-GetDEResults(dds)
#DE: 37 <0.05 /25 <0.01

CL_DESeq2Results<-resOrdered

rownames(resOrdered[resOrdered$padj<0.01,])
```


Visualize DE results with heatmap:
```{r}
#normalize results
rld<- rlog(dds)

#plot
p<-PlotHeatmap(as.data.frame(resOrdered),rld, metadata,50, -.2,1,12)
```

Blocked/unblocked samples cluster together, as expected. Samples A/B and C/D also cluster together, as seen in the PCA results


Write to csv
```{r}
write.csv(resOrdered, paste(wd, "DESeq2Results/DESeq2Results_CLDownsampledMatureIsomir_121619.csv", sep =""))
```


DESeq2 Analysis 2: removing targeted miRNAs

Two variations
    a) excluding just the actual targets
    b) excluding the actual targets + members of the same family

#Variation A (only actual targets removed) 

```{r}
#Get list of all targets
ActualTargets<- c('hsa-miR-486-5p','hsa-miR-92a-3p','hsa-miR-451a')

#subset counts (mature only) by non-target miRNAs
counts_AT<- counts[!(rownames(counts) %in% ActualTargets),]
```

Create dds object, run DESeq2
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_AT, meta, TRUE)
```


Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<-GetDEResults(dds)
#31/21

rownames(resOrdered[resOrdered$padj<0.01,])

nrow(resOrdered[resOrdered$padj<0.01,])
nrow(resOrdered[resOrdered$padj<0.05,])

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<- PlotHeatmap(resOrdered, rld, metadata,50, -.2,1, 10)
```

In heatmap of DE results, for A/B, samples cluster by SAMPLE and not BLOCKER STATUS, as we would expect if there are no huge off target effects caused by the blockers. However- C/D still cluster by blocker status. Will look at removing targets+target families, next, see if C/D still cluster by blocker status



Write results to file:
```{r}
#write to file 
write.csv(resOrdered, paste(wd, "DESeq2Results/DESeq2Results_ActualTargetsRemoved_DownSampledCLCountMatrix_Pairwise_121619.csv", sep = "" ))
```



Variation B (actual targets + species in same family removed)

Only removed if they were at padj<0.05 in the previous analysis (actual targets removed)

Select all species with 92, 451, or 486 in name. Also select 2 hsa-mir-25 species (same family as 92a)
```{r}
#Entire list of all species in target family
Target_92<- rownames(counts_AT[grep("miR-92", rownames(counts_AT))[5:8],])
Target_451<- rownames(counts_AT[grep("miR-451", rownames(counts_AT))[11],])
Target_486<- rownames(counts_AT[grep("miR-486", rownames(counts_AT)),])
Target_25<- rownames(counts_AT[grep("miR-25", rownames(counts_AT)),])
TargetFamilies<- c(Target_451,Target_486,Target_92, Target_25)

#Use as supplemental figure: plotting target family species( not targets themselves) raw counts for blocked vs unblocked
counts_TargetFamilies<- counts[rownames(counts) %in% TargetFamilies,]
counts_TargetFamilies$Unblocked<- rowMeans(counts_TargetFamilies[,1:8,])
counts_TargetFamilies$Blocked<- rowMeans(counts_TargetFamilies[,9:16])
counts_TargetFamilies<- counts_TargetFamilies[,17:18]
counts_TargetFamilies$species<- rownames(counts_TargetFamilies)
counts_TargetFamilies<- counts_TargetFamilies[order(counts_TargetFamilies$Unblocked, decreasing=TRUE),]


#Remove target family species with low counts (<100 total)


#melt for plotting
counts_TargetFamilies_melt<- melt(counts_TargetFamilies)
counts_TargetFamilies_melt$order<- rep(1:8, 2)

p<- ggplot(counts_TargetFamilies_melt, aes(x=reorder(species, +order), y=value, fill=variable))+
        geom_bar(position="dodge", stat="identity")+
        theme_classic()+
        ylab("Number of raw counts")+
        xlab("")+
        scale_fill_manual("", values=c("Blocked"="firebrick3", "Unblocked"="turquoise3"))+
        theme(axis.text.y   = element_text(size=12, color="black", face= "bold"),
                axis.text.x   = element_text(size=5, color="black", face="bold", angle=45, hjust=1),
                axis.title.y  = element_text(size=16, color="black", face="bold"),
                panel.border = element_rect(colour = "black", fill=NA, size=2),
                legend.title=element_blank(),
                legend.background = element_rect(fill=NA, size=1, linetype="solid", color="black"),
                legend.text = element_text(size=14, face="bold"),
                axis.text.x.bottom  =element_text(size=14),
                legend.position = c(.75,.9))
#exported graph for supplemental figure: SupplementalFigure1_032320_TargetFamiliesCPM


#Remove only the one species (miR-25-3p) whose raw counts are clearly lower in blocked compared to unblocked
counts_DecreasedTargetFamiliesRemoved<- counts_AT[!(rownames(counts_AT) %in% "hsa-miR-25-3p"),]
```



Create dds object, run DESeq2, visualize with PCA
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_DecreasedTargetFamiliesRemoved,meta,TRUE)

```

Very similar to previous analysis (just actual targets removed), samples still cluster by SAMPLE TYPE not by blocker status

Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<- GetDEResults(dds)
#27 DE miRNAs- padj <0.05
#19 DE miRNAs- padj <0.01

rownames(resOrdered[resOrdered$padj<0.01,])

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<-PlotHeatmap(resOrdered, rld, metadata, 50, -.2,1.2,14)
```

Samples cluster fully by sample type, not blocker status!

when you remove not just the actual targets, but also the actual targets + species from the same family (as above), samples cluster FULLY by sample type, not blocker status- even for samples C/D


Write results to file:
```{r}
#write to file 
write.csv(resOrdered, paste(wd, "DESeq2Results/DESeq2Results_ActualTargets+FamiliesRemoved_DownSampledCLCountMatrix_Pairwise_121619.csv", sep = "" ))
```


One additional filtering method: cpm

Remove all species that don't meet a cpm threshold: >1 cpm in at least 1 sample in each group
```{r}
#Calculate cpm
counts_cpm<- counts /colSums(counts) *1000000

#Remove all species that don't have at least 1 unblocked sample with cpm > 1
UnblockedPass<- counts_cpm[rowSums(counts_cpm[,1:8]>1)>=1,] #2006/1807 removed- a lot of unblocked don't meet threshold. makes sense.

#Remove all species that don't have at least 1 blocked sample with cpm> 1
BlockedandUnblockedPass<- UnblockedPass[rowSums(UnblockedPass[,9:16]>1)>=1,] #8 more removed

#Get species that passed, filter counts based on this
counts_CPMfilter<- counts[rownames(counts) %in% rownames(BlockedandUnblockedPass),]
```

Also remove targets (+ 1 target family species that was decreased with blockers)
```{r}
Remove<- c(ActualTargets, "hsa-miR-25-3p"  )
counts_CPMfilter_RemoveTargets<- counts_CPMfilter[!(rownames(counts_CPMfilter) %in% Remove),]
```


Create dds object, run DESeq2
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_CPMfilter_RemoveTargets,meta,TRUE)
```

Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<- GetDEResults(dds)
#34 DE miRNAs- padj <0.05
#24 DE miRNAs- padj <0.01


sig<- as.data.frame(resOrdered[resOrdered$padj<0.01,])

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<-PlotHeatmap(resOrdered, rld, metadata, 100, -.2,1.2,14) #Figure 2C: exported as Figure2C_heatmap_CPMFilter_miR-25-3pAlsoRemoved

```




#Figure 2D: Log of CPM for each miRNA, comparing blocked vs unblocked values

Sig miRNAs colored in red

```{r}
#Use cpm calculated previously
#All species without at least 1 sample with at least 1 CPM in BOTH blocked and unblocked groups is removed - 565 miRNAs remain
CPMFinal<- BlockedandUnblockedPass

#log2 of CPM
CPMLog<- log10(CPMFinal+1) #+1 optional here
#CPMLog<- log10(CPMFinal)
#CPMLog<-CPMFinal

#Get miRNA info. Need: whether or not it was targeted + whether or not it was DE
#Add in target info- add column for whether or not the species was targeted
CPMLog$target<- rownames(CPMLog) %in% ActualTargets

#Add in DE info- using DESeq2 results from targets included analysis. Import data here.
CPMLog$Sig<- rownames(CPMLog) %in% rownames(sig)

#Add in third column, used to color points in graph. Add together target/sig columns. If it's a target and sig, it'll be 2, if it's just sig it'll be 1, if it's neither it'll be 0.
CPMLog$Color<- as.factor(rowSums(CPMLog[,17:18]))
CPMLog$Color<- gsub(1, "DE", CPMLog$Color)
CPMLog$Color<- gsub(0, "Not DE", CPMLog$Color)
CPMLog<-CPMLog[order(CPMLog$target, decreasing=TRUE),]
CPMLog[1:3, 19]<- c("Target", "Target", "Target")
CPMLog[grep("hsa-miR-25-3p", rownames(CPMLog)),19]<- "DE"


```


```{r}
#Looking at sample A- get average for all 3 Inputs
CPMLogA<- CPMLog[,c(1:3, 9:11,19)]
CPMLogA$NoBlocker<- rowMeans(CPMLogA[,1:3])
CPMLogA$Blocker<- rowMeans(CPMLogA[,4:6])
CPMLogA<- CPMLogA[,c(9,8,7)]

#Remove any species that are 0 in all
CPMLogA<- CPMLogA[rowSums(CPMLogA[,1:2]) > 0,]
CPMLogA<- na.omit(CPMLogA)

pA<- CPMPlot(CPMLogA, "Sample A")
```

Most species follow the same general trend for both blocked and unblocked- i.e., overall similar expression pattern. EXCEPT for the targets (plus a few off target effects) 

```{r}
#Looking at sample B- get average for all 3 Inputs
CPMLogB<- CPMLog[,c(4:6, 12:14,19)]
CPMLogB$NoBlocker<- rowMeans(CPMLogB[,1:3])
CPMLogB$Blocker<- rowMeans(CPMLogB[,4:6])
CPMLogB<- CPMLogB[,c(9,8,7)]

#Remove any species that are 0 in all
CPMLogB<- CPMLogB[rowSums(CPMLogB[,1:2]) > 0,]
CPMLogB<- na.omit(CPMLogB)

pB<- CPMPlot(CPMLogB, "Sample B")
```

```{r}
#For sample C
CPMLogC<- CPMLog[,c(7, 15,19)]
colnames(CPMLogC)<- c("NoBlocker", "Blocker", "Color")

#Remove any species that are 0 in all
CPMLogC<- CPMLogC[rowSums(CPMLogC[,1:2]) > 0,]
CPMLogC<- na.omit(CPMLogC)

pC<- CPMPlot(CPMLogC, "Sample C")
```

```{r}
#For sample D
CPMLogD<- CPMLog[,c(8, 16,19)]
colnames(CPMLogD)<- c("NoBlocker", "Blocker", "Color")

#Remove any species that are 0 in all
CPMLogD<- CPMLogD[rowSums(CPMLogD[,1:2]) > 0,]
CPMLogD<- na.omit(CPMLogD)

pD<- CPMPlot(CPMLogD, "Sample D")
```


```{r}
#Averaging values across al 4 samples
CPMLogAll<- CPMLog
CPMLogAll$NoBlocker<- rowMeans(CPMLogAll[,1:8])
CPMLogAll$Blocker<- rowMeans(CPMLogAll[,9:16])
CPMLogAll<- CPMLogAll[,c(19:21)]

pMean<- CPMPlot(CPMLogAll, "mean across all samples")
#Export as Figure2D_Log2CPMMeanAcrossSamples_032320
```

Putting A-D together on one plot:
```{r}
grid.arrange(pA+ggtitle(""), pB+ggtitle(""), pC+ggtitle(""), pD+ggtitle(""), nrow=2)
#Export as 032320_Figure_AllSamplesLogCPM
```

