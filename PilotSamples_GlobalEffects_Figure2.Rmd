---
title: "Blocker Project: Differential Expression using DESeq2- Command line miRDeep2 count matrix used"
output: html_notebook
---

#Using DESeq2 to perform differential expression on miRNASeq data, comparing blocked vs no blocked groups

These analyses used for Figure 2 or for supplemental figure 1. Some analyses not used in figure, but included here for completeness.

Note: most analyses performed on both miR counts generated by the Basespace small RNA app and by running miRDeep2 at the command line (default settings). Counts from Basespace small RNA app used in final analysis, but the option to use counts from miRDeep2 at the command line included here.


Import libraries:
```{r}
suppressPackageStartupMessages(library(DESeq2))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(metaseqR))
suppressPackageStartupMessages(library(colorRamps))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(dplyr))
windowsFonts("Arial" = windowsFont("Arial"))
```


#Functions used in analyses:
```{r}
#Create metadata and DESeq2 object, then run DESeq2
RunDESeq2<- function(counts,meta, collapseRep=TRUE) {
  #create DESeq2 object- just based on samplegroup (blockerstatus)
  #will add samples to model later (i.e., pairwise analysis)
  dds<- DESeqDataSetFromMatrix(countData=counts, 
                               colData=meta, 
                               design=~sampleGroup)
  #Collapse technical replicates using internal DESeq2 function
  if (collapseRep ==TRUE){
    dds<- collapseReplicates(dds, dds$sample)
  }
  
  #Create model that takes into account sample differences
  ddsMF<- dds
  design(ddsMF)<- formula(~Patient + sampleGroup)
  
  #run DESeq2
  dds<- DESeq(ddsMF)
  
  return(dds)
}

#Get DE results
GetDEResults<- function(dds){
  res<- results(dds)
  res<- na.omit(res)
  resOrdered<- res[order(res$padj),]
  print(nrow(resOrdered[resOrdered$padj<0.05,]))
  print(nrow(resOrdered[resOrdered$padj<0.01,]))
  return(resOrdered)
}

#Plot PCA nicely
MyPCA<- function(dds, metadata, PC1Variance, PC2Variance, Groupcolors,miny, maxy, minx, maxx) {
  #Normalized (variance stabilized transformation), then run PCA
  vsd <- varianceStabilizingTransformation(dds, blind=TRUE)
  PCA<-plotPCA(vsd, intgroup="sampleGroup",returnData=TRUE)
  PCA$Patient<- metadata$Patient
  
  #plot
  p<- ggplot(PCA, aes(x=PC1, y=PC2, color=group, shape=Patient))+
  geom_point(size=8)+
  scale_color_manual(values=Groupcolors)+
  scale_shape_manual(values=c(15,20,43,18))+
  theme_classic()+
  ylim(miny,maxy)+
  xlim(minx,maxx)+
  ylab(paste("PC2: ", PC2Variance, "% Variance", sep =""))+
  xlab(paste("PC1: ", PC1Variance, "% Variance", sep =""))+
  #geom_text(aes(label=Sample),hjust=.5, size= 5,vjust=-1.2, color="black")+
  theme(axis.text.y   = element_text(size=12, colour = "black", face="bold"),
        axis.title.y  = element_text(size=14, colour = "black", face="bold"),
        axis.title.x  = element_text(size=14, colour = "black", face="bold"),
        axis.text.x  = element_text(size=12, colour = "black", face="bold"),
        legend.background = element_rect(fill=NA, size=1, 
                                         linetype="solid", color="black"),
        legend.title=element_blank(),
        legend.text = element_text(size=14, face="bold"),
        legend.key.size = unit(.4, "cm"),
        legend.spacing.y = unit(0, "mm"),
        legend.position = c(.9,.85),
        panel.border = element_rect(colour = "black", fill=NA, size=2)
        )
  return(p)
}

#For plotting PCA without collapsing technical replicates
MyPCA_TechNotCollapsed<- function(counts, meta,PC1, PC2, miny, maxy, minx, maxx){
  #Rename samples
  TechNotCollapsed<- counts
  colnames(TechNotCollapsed)<- c(paste("A.0.", 1:3,sep=""), paste("B.0.", 1:3,sep=""), "C.0", "D.0", paste("A.1.", 1:3,sep=""), paste("B.1.", 1:3,sep=""), "C.1", "D.1")


  #create DESeq2 object
  dds_TNC<- DESeqDataSetFromMatrix(countData=TechNotCollapsed, 
                             colData=meta, 
                             design=~sampleGroup)


  #Create model that takes into account sample differences
  ddsMF_TNC<- dds_TNC
  design(ddsMF_TNC)<- formula(~Patient + sampleGroup)

  #run DESeq2
  dds_TNC<- DESeq(ddsMF_TNC)
  
  #Run through MyPCA function to plot
  p<- MyPCA(dds_TNC, meta, PC1, PC2, Groupcolors, miny, maxy, minx, maxx)
  return(p)
}
  


#Plot heatmap: takes as input DE results (padj ordered lowest to highest, rlog transformed data, metadata (blocker status and Sample type), number of miRNA species to be included, and min and max subtract (used for heatmap aesthetics))
PlotHeatmap<- function(OrderedResults, rld, metadata, nspecies, MinSubtract, MaxSubtract, fontsize){
  #Select top sig DE miRNAs
  topgenes<- rownames(OrderedResults[1:nspecies,])
  mat<- assay(rld)[topgenes,]
  mat<- mat - rowMeans(mat)
  colnames(mat)<-paste(metadata$Patient," (",metadata$sampleGroup, ")",sep="")
  
  #Heatmap settings
  mat_breaks<- seq(min(mat-MinSubtract), max(mat-MaxSubtract), length.out=75)

  #Create metadata- to be used to color code to show which group the sample belongs to
  metadata<- data.frame(Group=metadata$sampleGroup, 
                        row.names=paste(metadata$Patient," (",metadata$sampleGroup, ")",sep=""),
                        Sample=metadata$Patient)

  #plot heatmap
  p<-pheatmap(mat, breaks = mat_breaks, 
            color =colorRampPalette( c("red", "black", "green"), space="rgb")(100),
            show_rownames = TRUE, show_colnames=FALSE,
            annotation = metadata,
            annotation_colors= list(
              Group=c(Blocked="firebrick3", Unblocked="turquoise3"),
                      Sample=c(A="goldenrod1", 
                               B="violetred3", 
                               C="skyblue3", 
                               D="darkolivegreen4")),
            fontsize_row = fontsize,fontsize=12,treeheight_row=0,
            border_color= NA)
  return(p)
}

#Plot log2 CPM nicely
CPMPlot<- function(CPM, Sample){
  #Get subset of CPM for labeling points- points that are both sig DE and are higher in unblocked than   blocked (beneath the slope line)
  CPM$HigherInUnblocked<- (CPM$Blocker-CPM$NoBlocker)<0
  SubsetToLabel<- CPM[CPM$HigherInUnblocked=="TRUE" &CPM$Color!="Not DE",]
  
  #Plot
  p<- ggplot(CPM, aes(x=NoBlocker, y=Blocker, color=Color))+
  geom_point(size=3)+
  geom_abline(slope=1, color="red")+
  scale_colour_manual(values=c("red","black", "blue"))+
  theme_classic()+
  xlim(0,6)+
  ylim(0,6)+
  xlab(paste("Log2 of Unblocked Counts Per Million"))+
  ylab(paste("Log2 of Blocked Counts Per Million"))+
  geom_text_repel(data=SubsetToLabel, aes(x=NoBlocker, y=Blocker, label=rownames(SubsetToLabel)), color="black",  size=5, fontface="bold")+
  ggtitle(Sample)+
  theme(axis.text.y   = element_text(size=14, colour = "black", face="bold"),
        axis.title.y  = element_text(size=14, colour = "black", face="bold"),
        axis.title.x  = element_text(size=14, colour = "black", face="bold"),
        axis.text.x  = element_text(size=14, colour = "black", face="bold"),
        legend.background = element_rect(fill=NA, size=1, 
                                         linetype="solid", color="black"),
        legend.title=element_blank(),
        legend.key.size = unit(.4, "cm"),
        legend.spacing.y = unit(0, "mm"),
        legend.position = c(.15,.892),
        legend.text = element_text(size=18, face="bold"),
        panel.border = element_rect(colour = "black", fill=NA, size=2),
        plot.title=element_text(size=14, face="bold"))
  return(p)
  
}


#Convience function for collapsing A and B technical replicates
CollapseAandB<-function(counts){
        counts$A.0<- rowMeans(counts[,1:3])
        counts$B.0<- rowMeans(counts[,4:6])
        counts$A.1<- rowMeans(counts[,9:11])
        counts$B.1<- rowMeans(counts[,12:14])
        counts<-counts[,c(17,18,7,8,19,20,15,16)]
        colnames(counts)<-c("A.0", "B.0", "C.0", "D.0", "A.1", "B.1", "C.1", "D.1")
        return(counts)
}


```



#Notes on DESeq2 Analysis:

-Since there are 4 sample types (A/B/C/D) each with at least one blocked/unblocked pair, pairwise DESeq2 analysis is performed

-Samples A and B have 3 technical replicates, for both blocked and unblocked groups. These technical replicates are collapsed using an internal DESeq2 function. These technical replicates have varying RNA input amounts into library construction, but this was determined to have no effect on the resulting libraries (See Figure1A Notebook). This is additionally confirmed by PCA clustering here.


#Overall steps:

1. Read in raw counts data (miRDeep2 Default settings OR BaseSpace counts) and downsample to common depth
2. Principal component analysis (Figure 2A)
3. Differential expression: blocked samples vs unblocked samples (Figure 2B-C, supplemental figure 1D)
4: Log of CPM for each miRNA, comparing blocked vs unblocked values (Figure 2D)


#1: Read in data and downsample

Two input data options: pilot data from CL miRDeep2 analysis or pilot data from BaseSpace miRDeep2. Basespace data used for final figure
```{r}
#Read in raw couns from default CL miRDeep2 
countsInput<- read.csv("C:/Users/Jenna/Documents/BlockerProject/miRNA_CLmiRDeep2Results_AllSamples_DefaultmiRDeep2Settings.csv")
rownames(countsInput)<-countsInput$X
countsInput<- countsInput[,-1]
countsInput<- countsInput[,c(1,3,5,7,9,11,13,15,2,4,6,8,10,12,14,16)]
colnames(countsInput)<- c(paste(c("A:low", "A:medium", "A:high", "B:low", "B:medium", "B:high", "C", "D"), "-Unblocked",sep=""),
                          paste( c("A:low", "A:medium", "A:high","B:low", "B:medium", "B:high", "C", "D"), "-Blocked",sep="" ))


#Convert values to integer
counts<-as.data.frame(apply(countsInput, 2, as.integer))
rownames(counts)<- rownames(countsInput)
rownames(counts)<- gsub("hsa-", "", rownames(counts))

#Read in raw counts from Basespace- mature and isomir
wd<- "C:/Users/Jenna/Documents/BlockerProject/"
BaseSpace_countsInput<- read.delim(paste(wd, "mirna-blocker_bs_mature-isomirs_raw.txt", sep =""))
rownames(BaseSpace_countsInput)<- BaseSpace_countsInput$ID
BaseSpace_counts<-BaseSpace_countsInput[,c(4:ncol(BaseSpace_countsInput))]
colnames(BaseSpace_counts)<- c(paste(c("A:low", "A:medium", "A:high", "B:low", "B:medium", "B:high", "C", "D"), "-Unblocked",sep=""),
                          paste( c("A:low", "A:medium", "A:high","B:low", "B:medium", "B:high", "C", "D"), "-Blocked",sep="" ))

        #For basespace input count matrix: merge isomir and mature
        
        #Collapse counts-remove everything after 3rd "-" (-1, -5p, etc), then merge and sum together based on new miR IDs
        BaseSpace_collapsedInput<-BaseSpace_counts
        BaseSpace_collapsedInput$geneIDs<- sub("^([^-]*-[^-]*-[^-]*).*", "\\1", rownames(BaseSpace_collapsedInput))
        BaseSpace_collapsedInput$geneIDs<- gsub("mir", "miR", BaseSpace_collapsedInput$geneIDs)
        
        #Collapse isomirs and mature toegether
        BaseSpace_collapsed<-BaseSpace_collapsedInput %>% group_by(geneIDs) %>% summarise_each(funs(sum)) %>% as.data.frame
        rownames(BaseSpace_collapsed)<-BaseSpace_collapsed$geneIDs
        BaseSpace_collapsed<- BaseSpace_collapsed[,2:ncol(BaseSpace_collapsed)]
        rownames(BaseSpace_collapsed)<- gsub("hsa-", "", rownames(BaseSpace_collapsed))

#Set the input matrix to be used
countsInput<-BaseSpace_collapsed

#Downsample to common depth
counts<- downsample.counts(countsInput, set.seed(42)) #9,989,167 lowest B.570.0 /7.97 million for basespace
```



#2: Principal component analysis (Figure 2A)


```{r}
#Need to detach DESeq (need to use DESeq2)- used for metaseqR
detach("package:metaseqR")
detach("package:DESeq")
```

General plotting variables
```{r}
Groupcolors<- c("firebrick3","turquoise3")
Samplecolors<- c("goldenrod1","violetred3", "skyblue3", "darkolivegreen4")

metadata<- data.frame(sampleGroup=rep(c("Unblocked", "Blocked"),4), Patient=c("A", "A", "B", "B", "C", "C", "D", "D"))
```


Prep data for DESeq2, create metadata, then create DESeq2 object for PCA plotting:
```{r}
#rename rows, removing input info
colnames(counts)<- c(rep("A.0", 3), rep("B.0", 3), "C.0", "D.0", rep("A.1", 3), rep("B.1", 3), "C.1", "D.1")

#Create metadata- will be used in all analyses- when collapsing technical replicates and when leaving separate:
sampleGroup<- factor(c(rep("Unblocked", 8), rep("Blocked", 8)), levels=c("Unblocked", "Blocked")) #set blocker status
sample<- colnames(counts) #this column is used to collapse technical replicates
Patient<- as.factor(c(rep("A", 3), rep("B", 3), "C", "D", rep("A", 3), rep("B", 3), "C", "D")) #this column is to control for sample to sample differences
meta<- data.frame(sample, sampleGroup, Patient)

#Run DESeq2- using custom function (just for using the DESeq2 object created from this function)
#Technical replicates are collapsed and pairwise analysis performed

dds<- RunDESeq2(counts, meta, TRUE)
```


Visualize sample differences using PCA

Note: this function uses the dds object, but no information on sample group is input into the analysis (i.e., unsupervised clustering)
Technical replicates are collapsed. This plot not used as figure.
```{r}
#Plot PCA using DESeq2 functions, get % variance from here. Input for custom function.
plotPCA(varianceStabilizingTransformation(dds), intgroup="sampleGroup")

p<-MyPCA(dds, metadata, 43, 18, Groupcolors,-15,20, -20,25)
```


Repeat PCA, not collapsing technical replicates- Figure 2A
```{r}
#Run deseq2 --> plot on PCA
p<- MyPCA_TechNotCollapsed(counts, meta, 43, 18, -20,27,-25,28) 

p<-p+scale_y_continuous(breaks=seq(-20,20,10))+scale_x_continuous(breaks=seq(-20,25,10))+theme(legend.position = c(.85,.2))+ylim(-20,20)
```



#3. Differential expression: blocked samples vs unblocked samples (Figure 2B-C)

For all analyes, technical replicates are collapsed.

Four versions of DE performed:
1. No modification- just paired/tech collapsed
2. Removing 3 target miRs from count matrix prior to DE
3. Removing 3 target miRs  + miR-25 from count matrix prior to DE
4: Filter based on CPM (Figure 2B)
5: Filter based on CPM + Remove 3 targets + Remove miR-25 (Figure 2C)


#DE Version 1: No modification- just paired/tech collapsed (not used as figure): 
```{r}
dds<- RunDESeq2(counts, meta, TRUE)

resOrdered<-GetDEResults(dds)
#DE: 37 <0.05 /25 <0.01 (CL)
#DE: 29 <0.05/ 22 <0.01 (BS)

rownames(resOrdered[resOrdered$padj<0.01,])
```


Visualize DE results with heatmap:
```{r}
#normalize results
rld<- rlog(dds)

#plot
p<-PlotHeatmap(as.data.frame(resOrdered),rld, metadata,50, -.2,1,6)
```

Blocked/unblocked samples cluster together, as expected. Samples A/B and C/D also cluster together, as seen in the PCA results



#DE Version 2:  excluding 3 target miRs (not used as figure)
   
```{r}
#Get list of all targets
ActualTargets<- c('miR-486-5p','miR-92a-3p','miR-451a') #CL
ActualTargets<- c('miR-486','miR-92a','miR-451a') #BS

#subset counts (mature only) by non-target miRNAs
counts_AT<- counts[!(rownames(counts) %in% ActualTargets),]
```

Create dds object, run DESeq2
```{r}
#Run DESeq2
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_AT, meta, TRUE)
```


Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<-GetDEResults(dds)
#31/21 for CL
#27/20 for BS

rownames(resOrdered[resOrdered$padj<0.01,])

nrow(resOrdered[resOrdered$padj<0.01,])
nrow(resOrdered[resOrdered$padj<0.05,])

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<- PlotHeatmap(resOrdered, rld, metadata,100, -.2,1, 6)
```

In heatmap of DE results, for A/B, samples cluster by SAMPLE and not BLOCKER STATUS, as we would expect if there are no huge off target effects caused by the blockers. 



#Variation 3: Removing 3 target miRs + miR-25 from count matrix prior to DE (not used as figure)
*miR-25 results used as supplemental figure 1D

Before DE: justification for removing miR-25 from count matrix
Select all species with 92, 451, or 486 in name. Also select 2 hsa-mir-25 species (same family as 92a)
```{r}
#Entire list of all species in target family
Target_92<- rownames(counts_AT[grep("miR-92", rownames(counts_AT)),])[5]
Target_451<- rownames(counts_AT[grep("miR-451", rownames(counts_AT)),])[11]
Target_486<- rownames(counts_AT[grep("miR-486", rownames(counts_AT)),])
Target_25<- rownames(counts_AT[grep("miR-25", rownames(counts_AT)),])
TargetFamilies<- c(Target_451,Target_486,Target_92, Target_25)

#Use as supplemental figure: plotting target family species( not targets themselves) raw counts for blocked vs unblocked
counts_TargetFamilies<- counts[rownames(counts) %in% TargetFamilies,]
counts_TargetFamilies$Unblocked<- rowMeans(counts_TargetFamilies[,1:8,])
counts_TargetFamilies$Blocked<- rowMeans(counts_TargetFamilies[,9:16])
counts_TargetFamilies<- counts_TargetFamilies[,17:18]
counts_TargetFamilies$species<- rownames(counts_TargetFamilies)
counts_TargetFamilies<- counts_TargetFamilies[order(counts_TargetFamilies$Unblocked, decreasing=TRUE),]


#melt for plotting
counts_TargetFamilies_melt<- melt(counts_TargetFamilies)
counts_TargetFamilies_melt$order<- rep(1:nrow(counts_TargetFamilies), 2)

p<- ggplot(counts_TargetFamilies_melt, aes(x=reorder(species, +order), y=value, fill=variable))+
        geom_bar(position="dodge", stat="identity")+
        theme_classic()+
        ylab("Number of raw counts")+
        xlab("")+
        scale_fill_manual("", values=c("Blocked"="firebrick3", "Unblocked"="turquoise3"))+
        theme(axis.text.y   = element_text(size=12, color="black", face= "bold"),
                axis.text.x   = element_text(size=5, color="black", face="bold", angle=45, hjust=1),
                axis.title.y  = element_text(size=16, color="black", face="bold"),
                panel.border = element_rect(colour = "black", fill=NA, size=2),
                legend.title=element_blank(),
                legend.background = element_rect(fill=NA, size=1, linetype="solid", color="black"),
                legend.text = element_text(size=14, face="bold"),
                axis.text.x.bottom  =element_text(size=14),
                legend.position = c(.75,.9))


#Remove only the one species (miR-25-3p) whose raw counts are clearly lower in blocked compared to unblocked
counts_DecreasedTargetFamiliesRemoved<- counts_AT[!(rownames(counts_AT) %in% "hsa-miR-25-3p"),]
```


Create dds object, run DESeq2
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_DecreasedTargetFamiliesRemoved,meta,TRUE)
```


Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<- GetDEResults(dds)
#29/20 DE miRNAs- CL
#27/20 DE miRNAs- BS

rownames(resOrdered[resOrdered$padj<0.01,])

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<-PlotHeatmap(resOrdered, rld, metadata, 100, -.2,1.2,6)
```

when you remove not just the actual targets, but also the actual targets + species from the same family (as above), samples cluster FULLY by sample type, not blocker status- even for samples C/D


#Variation 4: Filter based on CPM (Figure 2B)

Remove all species that don't meet a cpm threshold: >2 cpm in at least 50% of samples in each group
```{r}
#Collapse A and B technical replicates
counts_collapsed<-counts
counts_collapsed$A.0.c<-rowMeans(counts_collapsed[,1:3])
counts_collapsed$B.0.c<-rowMeans(counts_collapsed[,4:6])
counts_collapsed$A.1.c<-rowMeans(counts_collapsed[,9:11])
counts_collapsed$B.1.c<-rowMeans(counts_collapsed[,12:14])
counts_collapsed<- counts_collapsed[,c(17,18,7,8,19,20,15,16)]

#Calculate cpm. convert to integer
counts_cpm<- counts_collapsed /colSums(counts_collapsed) *1000000
counts_cpm<- apply(counts_cpm, 2, as.integer)
rownames(counts_cpm)<-rownames(counts_collapsed)

#Remove all species that don't have more than 1 unblocked sample with cpm > 1
UnblockedPass<- counts_cpm[rowSums(counts_cpm[,1:4]>1)>1,] #- #2261 species removed- a lot of unblocked don't meet threshold. makes sense.

#Remove all species that don't have at least 1 blocked sample with cpm> 1
BlockedandUnblockedPass<- UnblockedPass[rowSums(UnblockedPass[,5:8]>1)>1,] #none removed

#Get species that passed, filter counts based on this
counts_CPMfilter<- counts[rownames(counts) %in% rownames(BlockedandUnblockedPass),]
```

Create dds object, run DESeq2
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_CPMfilter,meta,TRUE)
```

Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<- GetDEResults(dds)
#38/26 DE miRNAs- CL
#30/22 DE miRNAs-  BS

sig<- as.data.frame(resOrdered[resOrdered$padj<0.01,]) #26
#optional- set sig as being padj<0.01 + basemean >50
sig<-as.data.frame(sig[sig$baseMean>=50,]) #doesn't remove any if using BS counts

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<-PlotHeatmap(resOrdered, rld, metadata, 50, -.2,.9,11)
```
Samples cluster by blocker status


#Variation 5: Filter based on CPM + Remove 3 targets + Remove miR-25 (Figure 2C)

Remove targets (+ 1 target family species that was decreased with blockers)
```{r}
Remove<- c(ActualTargets, "miR-25-3p"  ) #CL miRDeep2
Remove<- c(ActualTargets, "miR-25"  ) #Basespace miRDeep2
counts_CPMfilter_RemoveTargets<- counts_CPMfilter[!(rownames(counts_CPMfilter) %in% Remove),]
```


Create dds object, run DESeq2
```{r}
#Run DESeq2: custom functions can be found in Functions.Rmd file
#Technical replicates are collapsed and pairwise analysis performed
dds<- RunDESeq2(counts_CPMfilter_RemoveTargets,meta,TRUE)
```

Extract DESeq2 results and visualize with heatmap
```{r}
resOrdered<- GetDEResults(dds)
#32/22 DE miRNAs- CL
#25/18 DE miRNAs- BS

#remove hsa
rownames(resOrdered)<- gsub("hsa-", "", rownames(resOrdered))

#normalize results
rld<- rlog(dds)
```

Plot heatmap
```{r}
p<-PlotHeatmap(resOrdered, rld, metadata, 50, -.2,1.2,11) 

```

Samples cluster fully by sample type, not by blocker status



#4: Log2 of CPM for each miRNA, comparing blocked vs unblocked values (Figure 2D)

Sig miRNAs colored in red
```{r}
#Use cpm calculated previously
#All species without more than 1 sample with at least 1 CPM in BOTH blocked and unblocked groups is removed - 565 miRNAs remain
CPMFinal<-as.data.frame(BlockedandUnblockedPass)

#log2 of CPM
CPMLog<- log2(CPMFinal+1) 

#Get miRNA info. Need: whether or not it was targeted + whether or not it was DE
#Add in target info- add column for whether or not the species was targeted
CPMLog$target<- rownames(CPMLog) %in% ActualTargets

#Add in DE info- using DESeq2 results from targets included analysis. Import data here.
CPMLog$Sig<- rownames(CPMLog) %in% rownames(sig)

#Add in third column, used to color points in graph. Add together target/sig columns. If it's a target and sig, it'll be 2, if it's just sig it'll be 1, if it's neither it'll be 0.
CPMLog$Color<- as.factor(rowSums(CPMLog[,9:10]))
CPMLog$Color<- gsub(1, "DE", CPMLog$Color)
CPMLog$Color<- gsub(0, "Not DE", CPMLog$Color)
CPMLog<-CPMLog[order(CPMLog$target, decreasing=TRUE),]
CPMLog[1:3, 11]<- c("Target", "Target", "Target")
#CPMLog[grep("miR-25-3p", rownames(CPMLog)),11]<- "DE" #CL
CPMLog[grep("miR-25", rownames(CPMLog)),11]<- "DE" #BS
```


Log2 CPMs plotted separately for all 4 samples. Mean CPM used in final figure. 
```{r}
#sample A
CPMLogA<-CPMLog[,c(1,5,11)]
colnames(CPMLogA)<-c("NoBlocker", "Blocker", "Color")
pA<- CPMPlot(CPMLogA, "Sample A")
```

```{r}
#sample B
CPMLogB<-CPMLog[,c(2,6,11)]
colnames(CPMLogB)<-c("NoBlocker", "Blocker", "Color")
pB<- CPMPlot(CPMLogB, "Sample B")
```

```{r}
#For sample C
CPMLogC<- CPMLog[,c(3, 7,11)]
colnames(CPMLogC)<- c("NoBlocker", "Blocker", "Color")
pC<- CPMPlot(CPMLogC, "Sample C")
```

```{r}
#For sample D
CPMLogD<- CPMLog[,c(4, 8,11)]
colnames(CPMLogD)<- c("NoBlocker", "Blocker", "Color")
pD<- CPMPlot(CPMLogD, "Sample D")
```

Final figure 2D:
```{r}
#Averaging values across al 4 samples
CPMLogAll<- CPMLog
CPMLogAll$NoBlocker<- rowMeans(CPMLogAll[,1:4])
CPMLogAll$Blocker<- rowMeans(CPMLogAll[,5:8])
CPMLogAll<- CPMLogAll[,c(11:13)]

pMean<- CPMPlot(CPMLogAll, "mean across all samples")

p<- pMean+ theme(axis.ticks = element_line(colour = "black", size =2), 
                 axis.ticks.length = unit(2,"mm"))+
        xlim(0,20)+
        ylim(0,20)+
        theme(axis.title.x = element_text(size=20),
              axis.title.y = element_text(size=20))+
        ggtitle("none")

```


Putting A-D together on one plot:
```{r}
grid.arrange(pA, pB, pC, pD, nrow=2)
```


```{r}
sessionInfo()
```

